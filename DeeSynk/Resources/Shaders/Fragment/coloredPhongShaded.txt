#version 450 core

in vec4 vs_lightCoord;

in vec3 vs_EyeCoord;
in vec3 vs_Normal;
in vec3 vs_TransPos;
in vec3 vs_TransPosi[4];

layout(binding = 1) uniform sampler2D shadow;
layout(binding = 2) uniform Camera
{
	mat4 projection;  //model_view
	vec4 camLocation; //cameraLoc
} camera;

layout(binding = 3) uniform SpotLight
{
	mat4 spotLightView;
	vec4 spotLightLocation;
	vec4 spotLightLookAt;
	vec4 spotLightColor;
	vec4 spotLightFOV;
} spotLights[4];

layout (location = 17) uniform vec4 color;

out vec4 color_Out;

uniform float fallOutDivisor = 5.0;
uniform float shadowBrightness = 0.2;
uniform float nonShadowBrightness = 1.0;
uniform float dR = 1.0/ 8192.0;

float rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

float GetSF(vec2 uv, float z)
{
	float Depth = texture(shadow, uv).x;
	if(Depth < (z+0.0001))
		return shadowBrightness;
	else 
		return nonShadowBrightness;
}

float SF(vec4 lightCoord)
{
	vec3 ProjCoords = lightCoord.xyz / lightCoord.w;
	vec2 UVCoords;
	UVCoords.x = 0.5 * ProjCoords.x + 0.5;
	UVCoords.y = 0.5 * ProjCoords.y + 0.5;
	float z = ProjCoords.z + 0.0001;
	float Depth = texture(shadow, UVCoords).x;
	float dr = 1/8192;
	float DepthA = texture(shadow, vec2(UVCoords.x + dr, 0)).x;
	float DepthB = texture(shadow, vec2(UVCoords.x - dr, 0)).x;
	float DepthC = texture(shadow, vec2(0, UVCoords.y + dr)).x;
	float DepthD = texture(shadow, vec2(0, UVCoords.y - dr)).x;

	float D1 = mix(Depth, DepthA, DepthB);
	float D2 = mix(Depth, DepthC, DepthD);
	float D3 = mix(D1, D2, Depth);

	//return 1.4 * pow(D3 - z, 2.0) + 0.001;
	return pow(D3 - z, 2.0); //change 0.0 to 2.0
}
float ShadowFactor(vec4 lightCoord)
{
	vec3 ProjCoords = lightCoord.xyz / lightCoord.w;
	vec2 UVCoords;
	UVCoords.x = 0.5 * (ProjCoords.x) + 0.5;
	UVCoords.y = 0.5 * (ProjCoords.y) + 0.5;
	float z = ProjCoords.z;

	float Depth = texture(shadow, UVCoords).x;
	if(Depth < (z+0.0001))
		return shadowBrightness;
	else 
		return nonShadowBrightness;
}

float Attenuation(vec4 lightCoord)
{
	vec3 coord = lightCoord.xyz;
	return 1/pow((length(coord) / fallOutDivisor), 2.0);
}


void main(void)
{
	vec3 materialColor = color.xyz;
	vec3 iA = materialColor;
	vec3 iD = materialColor;
	vec3 iS = materialColor;

	float kA = 1.0;
	float kD = 0.07;
	float kS = 0.5;

	float a  = 250.0;

	vec3 Ip = kA * iA;

	float spotDot = dot(normalize(vs_TransPos), spotLights[0].spotLightLookAt.xyz);

	if(spotDot >= spotLights[0].spotLightFOV.x)
	{
		vec3 lightLoc = spotLights[0].spotLightLocation.xyz;

		vec3 Lm = normalize(lightLoc - vs_EyeCoord);
		vec3 N  = normalize(vs_Normal);

		float dDot = dot(Lm, N);

		vec3 Rm = normalize(2 * dDot * N - Lm);
		vec3 V  = normalize(camera.camLocation.xyz  - vs_EyeCoord);

		float sDot = dot(Rm, V);


		Ip += (kD * dDot * iD) * (pow(dDot - 0.5, 3.0) + 0.5);

		float trns = SF(vs_lightCoord); // Attenuation(vs_lightCoord);
		trns = 0.5 * atan(3.141 * (trns - 0.5)) + 0.5 + rand(vs_lightCoord.xy) / 40.0;
		Ip *= trns;
		if((sDot > 0.0 && dDot > 0.0))
			Ip += kS * pow(sDot, a) * iS;
	}
	else{
		Ip *= 0.05;
	}
	color_Out = vec4(Ip, 1.0);
}

	//trns = (log(trns*10)) + rand(vs_lightCoord.xy) / 40.0;
	//trns = pow(trns, 0.5) + rand(vs_lightCoord.xy) / 40.0;
	//float factor = 1.0;
	//vec4 c = col * min(sF , Attenuation(vs_lightCoord)); 
	//float val = (trns) * 4.0 + max(vs_dDot, 0.1);